/*
 * $Id: SACParser.jj,v 1.7 2005-08-26 14:21:02 waldbaer Exp $
 *
 * CSS Parser Project
 *
 * Copyright (C) 1999-2005 David Schweinsberg.  All rights reserved.
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 *
 * To contact the authors of the library:
 *
 * http://cssparser.sourceforge.net/
 * mailto:davidsch@users.sourceforge.net
 */

options {
	IGNORE_CASE = true;
	STATIC = false;
//    UNICODE_INPUT = false;
    USER_CHAR_STREAM = true;
//    DEBUG_TOKEN_MANAGER = true;
//    DEBUG_PARSER = true;
}

PARSER_BEGIN(SACParser)

package com.steadystate.css.parser;

import java.io.*;
import java.net.*;
import java.text.MessageFormat;
import java.util.*;
import org.w3c.css.sac.*;
import com.steadystate.css.parser.selectors.*;

/**
 * @author <a href="mailto:davidsch@users.sourceforge.net">David Schweinsberg</a>
 * @version $Id: SACParser.jj,v 1.7 2005-08-26 14:21:02 waldbaer Exp $
 */
public class SACParser extends AbstractSACParser implements Parser {

    private boolean _quiet = true;

    public SACParser() {
        this((CharStream) null);
    }

    public String getParserVersion() {
        return "http://www.w3.org/TR/REC-CSS2/";
    }

}

PARSER_END(SACParser)

TOKEN_MGR_DECLS :
{
    private boolean _quiet = true;
    private ErrorHandler errorHandler;

    private String trimBy(StringBuffer s, int left, int right) {
        int end = s.length();
        return s.toString().substring(left, end-right);
    }

    private String trimUrl(StringBuffer s) {
        StringBuffer s1 = new StringBuffer( trimBy(s, 4, 1).trim() );
        int end = s1.length() - 1;
        if ((s1.charAt(0) == '"' && s1.charAt(end) == '"')
            || (s1.charAt(0) == '\'' && s1.charAt(end) == '\''))
            return trimBy(s1, 1, 1);
        else
           return s1.toString();
    }
}

<DEFAULT> TOKEN :
{
    < S: ( " "|"\t"|"\r"|"\n"|"\f" )+ >
}

<DEFAULT> MORE :
{
  < "/*" > : COMMENT
}

<COMMENT> SKIP :
{
  < "*/" > : DEFAULT
}

<COMMENT> MORE :
{
  < ~[] > : COMMENT
}

<DEFAULT> TOKEN :
{
  < LBRACE: "{" >
| < RBRACE: "}" >
| < COMMA: "," >
| < DOT: "." >
| < SEMICOLON: ";" >
| < COLON: ":" >
| < ASTERISK: "*" >
| < SLASH: "/" >
| < PLUS: "+" >
| < MINUS: "-" >
| < EQUALS: "=" >
| < GT: ">" >
| < LSQUARE: "[" >
| < RSQUARE: "]" >
}

<DEFAULT> TOKEN :
{
  < HASH: "#" <NAME> >
}

<DEFAULT> TOKEN :
{
  < STRING: <STRING1> | <STRING2> > { matchedToken.image = trimBy(image, 1, 1); }
| < RROUND: ")" >
}

<DEFAULT> TOKEN :
{
//  < #URL: ["!","#","$","%","&","*"-"~"] | <NONASCII> | <ESCAPE> >
  < #URL: ["!","#","$","%","&","*"-"[","]"-"~"] | <NONASCII> | <ESCAPE> >
| < URI: "url(" ( <S> )* ( <STRING> | ( <URL> )* ) ( <S> )* <RROUND> > { matchedToken.image = trimUrl(image); }
}

<DEFAULT> TOKEN :
{
  < CDO: "<!--" >
| < CDC: "-->" >
| < INCLUDES: "~=" >
| < DASHMATCH: "|=" >
| < IMPORT_SYM: "@import" >
| < PAGE_SYM: "@page" >
| < MEDIA_SYM: "@media" >
| < FONT_FACE_SYM: "@font-face" >
| < CHARSET_SYM: "@charset" >
| < ATKEYWORD: "@" <IDENT> >
| < IMPORTANT_SYM: "!" ( <S> )? "important" >
| < INHERIT: "inherit" >
| < EMS: <NUM> "em" > { matchedToken.image = trimBy(image, 0, 2); }
| < EXS: <NUM> "ex" > { matchedToken.image = trimBy(image, 0, 2); }
| < LENGTH_PX: <NUM> "px" > { matchedToken.image = trimBy(image, 0, 2); }
| < LENGTH_CM: <NUM> "cm" > { matchedToken.image = trimBy(image, 0, 2); }
| < LENGTH_MM: <NUM> "mm" > { matchedToken.image = trimBy(image, 0, 2); }
| < LENGTH_IN: <NUM> "in" > { matchedToken.image = trimBy(image, 0, 2); }
| < LENGTH_PT: <NUM> "pt" > { matchedToken.image = trimBy(image, 0, 2); }
| < LENGTH_PC: <NUM> "pc" > { matchedToken.image = trimBy(image, 0, 2); }
| < ANGLE_DEG: <NUM> "deg" > { matchedToken.image = trimBy(image, 0, 3); }
| < ANGLE_RAD: <NUM> "rad" > { matchedToken.image = trimBy(image, 0, 3); }
| < ANGLE_GRAD: <NUM> "grad" > { matchedToken.image = trimBy(image, 0, 4); }
| < TIME_MS: <NUM> "ms" > { matchedToken.image = trimBy(image, 0, 2); }
| < TIME_S: <NUM> "s" > { matchedToken.image = trimBy(image, 0, 1); }
| < FREQ_HZ: <NUM> "Hz" > { matchedToken.image = trimBy(image, 0, 2); }
| < FREQ_KHZ: <NUM> "kHz" > { matchedToken.image = trimBy(image, 0, 3); }
| < DIMEN: <NUM> <IDENT> >
| < PERCENTAGE: <NUM> "%" > { matchedToken.image = trimBy(image, 0, 1); }
| < NUMBER: <NUM> >
| < RGB: "rgb(" >
| < FUNCTION: <IDENT> "(" >
| < IDENT: <NMSTART> ( <NMCHAR> )* >
| < #NAME: ( <NMCHAR> )+ >
| < NUM: ( ["0"-"9"] )+ | ( ["0"-"9"] )* "." ( ["0"-"9"] )+ >

| < UNICODERANGE: "U+" ( <RANGE> | ( <HNUM> "-" <HNUM> ) ) >
| < #RANGE: <Q16> | <H> ( (<Q15>)? | <H> ( (<Q14>)? | <H> ( (<Q13>)? | <H> ( (<Q12>)? | <H> ( (<Q11>)? | <H> ) ) ) ) ) >
| < #Q16: "?" | "??" | "???" | "????" | "?????" | "??????" >
| < #Q15: "?" | "??" | "???" | "????" | "?????" >
| < #Q14: "?" | "??" | "???" | "????" >
| < #Q13: "?" | "??" | "???" >
| < #Q12: "?" | "??" >
| < #Q11: "?" >

| < #NMSTART: ["_","a"-"z"] | <NONASCII> | <ESCAPE> >
| < #NMCHAR: ["_","a"-"z","0"-"9","-"] | <NONASCII> | <ESCAPE> >
//| < #STRING1: "\"" ( ["\t"," ","!","#","$","%","&","("-"~"] | "\\" <NL> | "\'" | <NONASCII> | <ESCAPE> )* "\"" >
//| < #STRING2: "\'" ( ["\t"," ","!","#","$","%","&","("-"~"] | "\\" <NL> | "\"" | <NONASCII> | <ESCAPE> )* "\'" >
| < #STRING1: "\"" ( ["\t"," ","!","#","$","%","&","("-"[","]"-"~"] | "\\" <NL> | "\'" | <NONASCII> | <ESCAPE> )* "\"" >
| < #STRING2: "\'" ( ["\t"," ","!","#","$","%","&","("-"[","]"-"~"] | "\\" <NL> | "\"" | <NONASCII> | <ESCAPE> )* "\'" >
| < #NONASCII: ["\u0080"-"\uFFFF"] >
| < #ESCAPE: <UNICODE> | ( "\\" [" "-"~","\u0080"-"\uFFFF"] ) >
| < #NL: "\n" | "\r\n" | "\r" | "\f" >
| < #UNICODE: "\\" <HNUM> ( " " | "\t" | "\r" | "\n" | "\f" )? >
| < #HNUM: <H> | <H><H> | <H><H><H> | <H><H><H><H> | <H><H><H><H><H> | <H><H><H><H><H><H> >
| < #H: ["0"-"9","a"-"f"] >
}

<*> TOKEN:
{
    < UNKNOWN: ~[] >
    {
        if (!_quiet) {
            System.err.println("Illegal character : " + image.toString());
        }
    }
}

//
// stylesheet
//  : [ CHARSET_SYM S* STRING S* ';' ]?
//      [S|CDO|CDC]* [ import [S|CDO|CDC]* ]*
//      [ [ ruleset | media | page | font_face ] [S|CDO|CDC]* ]*
//  ;
//
void styleSheet() :
{
}
{
    try
    {
        { this.handleStartDocument(); }
        styleSheetRuleList()
        <EOF>
    }
    finally
    {
    	this.handleEndDocument();
    }
}

void styleSheetRuleList() :
{
}
{
    ( charsetRule() )?
    ( <S> | <CDO> | <CDC> )*
    ( importRule() ( <S> | <CDO> | <CDC> )* )*
    (
     ( styleRule() | mediaRule() | pageRule() | fontFaceRule() | unknownRule() )
     ( <S> | <CDO> | <CDC> )*
    )
    (
     ( styleRule() | mediaRule() | pageRule() | fontFaceRule() | importRuleIgnored() | unknownRule() )
     ( <S> | <CDO> | <CDC> )*
    )*
}

//
// This is used by ASTStyleSheet.insertRule to parse a single rule
//
void styleSheetRuleSingle() :
{
}
{
  ( charsetRule() | importRule() | styleRule() | mediaRule() | pageRule() | fontFaceRule() | unknownRule() )
}

void charsetRule() :
{
  Token t;
}
{
  <CHARSET_SYM> ( <S> )*
  t = <STRING> ( <S> )*
  <SEMICOLON>
}

void unknownRule() :
{
    Token t;
    String s;
}
{
    t = <ATKEYWORD>
    {
        s = skip();
        this.handleIgnorableAtRule(s);
    }
}

//
// import
//   : IMPORT_SYM S*
//     [STRING|URI] S* [ medium [ ',' S* medium]* ]? ';' S*
//   ;
//
void importRule() :
{
    Token t;
//    String s;
    SACMediaListImpl ml = new SACMediaListImpl();
}
{
    <IMPORT_SYM> ( <S> )*
    ( t = <STRING>
    | t = <URI> ) ( <S> )*
    ( mediaList(ml) )?
    <SEMICOLON>
    {
        this.handleImportStyle(unescape(t.image), ml, null);
    }
}

void importRuleIgnored() :
{
    Token t;
    SACMediaListImpl ml = new SACMediaListImpl();
}
{
    { ParseException e = generateParseException(); }
    try
    {
        <IMPORT_SYM>
        ( <S> )*
        ( t = <STRING>
        | t = <URI> ) ( <S> )*
        ( mediaList(ml) )?
        <SEMICOLON>
    }
    finally
    {
        this.getErrorHandler().error(this.toCSSParseException(e));
    }
}

//
// media
//   : MEDIA_SYM S* medium [ ',' S* medium ]* '{' S* ruleset* '}' S*
//   ;
//
void mediaRule() :
{
    boolean start = false;
    SACMediaListImpl ml = new SACMediaListImpl();
}
{
    try
    {
        <MEDIA_SYM> ( <S> )*
        mediaList(ml)
        {
            start = true;
            this.handleStartMedia(ml);
        }
        <LBRACE> ( <S> )*
        ( mediaRuleList() )?
        <RBRACE>
    }
    catch(ParseException e)
    {
        this.getErrorHandler().error(this.toCSSParseException(e));
        error_skipblock();
    }
    finally
    {
        if (start) {
            this.handleEndMedia(ml);
        }
    }
}

void mediaList(SACMediaListImpl ml) :
{
    String s;
}
{
    s = medium()
    ( <COMMA> ( <S> )* { ml.add(s); } s = medium() )*
    { ml.add(s); }
}

void mediaRuleList() :
{
}
{
  ( ( styleRule() | pageRule() | unknownRule() ) ( <S> )* )+ 
}

void mediaRuleSingle() :
{
}
{
  ( styleRule() | pageRule() | unknownRule() )
}

//
// medium
//   : IDENT S*
//   ;
//
String medium() :
{
  Token t;
}
{
  t = <IDENT> ( <S> )* { return t.image; }
}

//
// page
//   : PAGE_SYM S* IDENT? pseudo_page? S*
//     '{' S* declaration [ ';' S* declaration ]* '}' S*
//   ;
//
void pageRule() :
{
    Token t = null;
    String s = null;
    boolean start = false;
}
{
    try {
        <PAGE_SYM> ( <S> )*

        ( LOOKAHEAD(2) ( t = <IDENT> ( <S> )* ) |
        ( t = <IDENT> s = pseudoPage() ( <S> )* ) |
        ( s = pseudoPage() ( <S> )* ) )?

        //  ( t = <IDENT> { jjtThis.setIdent( t.image ); } )?
        //  ( s = pseudoPage() { jjtThis.setPseudoPage( s ); } )? ( <S> )*

        <LBRACE> ( <S> )*
        {
            start = true;
            this.handleStartPage((t != null) ? unescape(t.image) : null, s);
        }

        ( declaration() )?
        ( <SEMICOLON> ( <S> )* ( declaration() )? )*
        <RBRACE>
    } finally {
        if (start) {
            this.handleEndPage((t != null) ? unescape(t.image) : null, s);
        }
    }
}

//
// pseudoPage
//   : ':' IDENT
//   ;
//
String pseudoPage() :
{
  Token t;
}
{
  <COLON> t = <IDENT> { return t.image; }
}

//
// font_face
//   : FONT_FACE_SYM S*
//     '{' S* declaration [ ';' S* declaration ]* '}' S*
//   ;
//
void fontFaceRule() :
{
    boolean start = false;
}
{
    try {
        <FONT_FACE_SYM> ( <S> )*
        <LBRACE> ( <S> )* { start = true; this.handleStartFontFace(); }
        ( declaration() )?
        ( <SEMICOLON> ( <S> )* ( declaration() )? )*
        <RBRACE>
    } finally {
        if (start) {
            this.handleEndFontFace();
        }
    }
}

//
// operator
//   : '/' S* | ',' S* |
//   ;
//
LexicalUnit operator(LexicalUnit prev) :
{
  Token t;
}
{
  t = <SLASH> ( <S> )*   { return new LexicalUnitImpl(prev, LexicalUnit.SAC_OPERATOR_SLASH); }
  | t = <COMMA> ( <S> )* { return new LexicalUnitImpl(prev, LexicalUnit.SAC_OPERATOR_COMMA); }
}

//
// combinator
//   : '+' S* | '>' S* |
//   ;
//
char combinator() :
{
  char c = ' ';
}
{
  ( <PLUS> { c='+'; } ( <S> )*
  | <GT> { c='>'; } ( <S> )*
  | <S> ( ( <PLUS> { c='+'; } | <GT> { c='>'; } ) ( <S> )* )? )

  { return c; }
}

//
// unary_operator
//   : '-' | '+'
//   ;
//
char unaryOperator() :
{
}
{
  ( <MINUS> { return '-'; } | <PLUS> { return '+'; } )
}

//
// property
//   : IDENT S*
//   ;
//
String property() :
{
    Token t;
}
{
    t = <IDENT> ( <S> )*
    { return unescape(t.image); }
}

//
// ruleset
//   : selector [ ',' S* selector ]*
//     '{' S* declaration [ ';' S* declaration ]* '}' S*
//   ;
//
void styleRule() throws ParseException :
{
    SelectorList selList = null;
    boolean start = false;
    boolean noError = true;
}
{
    try {
        selList = selectorList()
        <LBRACE> ( <S> )*
        {
            start = true;
            this.handleStartSelector(selList);
        }
        ( declaration() )?
        ( <SEMICOLON> ( <S> )* ( declaration() )? )*
        <RBRACE>
    }
    catch(ParseException e)
    {
        this.getErrorHandler().error(this.toCSSParseException(e));
        noError = false;
        this.error_skipblock();
    }
    finally {
        if (start) {
            this.handleEndSelector(selList);
        }
    }
}

SelectorList selectorList() throws ParseException:
{
    SelectorListImpl selList = new SelectorListImpl();
    Selector sel;
}
{
    sel = selector()
    ( <COMMA> ( <S> )* { selList.add(sel); } sel = selector() )*
    {
        selList.add(sel);
        return selList;
    }
}

//
// selector
//   : simple_selector [ combinator simple_selector ]*
//   ;
//
Selector selector() :
{
    Selector sel;
    char comb;
}
{
    // throw exception when error occurs in selector
    //try {
        sel = simpleSelector(null, ' ')
        ( LOOKAHEAD(2) comb = combinator() sel = simpleSelector(sel, comb) )* ( <S> )*
        {
            return sel;
        }
    /*
    } catch (ParseException e) {
        skipSelector();
    }
    */
}

//
// simple_selector
//   : element_name? [ HASH | class | attrib | pseudo ]* S*
//   ;
//
Selector simpleSelector(Selector sel, char comb) :
{
    SimpleSelector simpleSel = null;
    Condition c = null;
}
{
    (
        ( simpleSel = elementName()
            ( c = hash(c)
            | c = _class(c)
            | c = attrib(c)
            | c = pseudo(c)
            )*
        )
        |
        ( { simpleSel = this.getSelectorFactory().createElementSelector(null, null); }
            ( c = hash(c)
            | c = _class(c)
            | c = attrib(c)
            | c = pseudo(c)
            )+
        )
    )

    {
        if (c != null) {
            simpleSel = this.getSelectorFactory().createConditionalSelector(simpleSel, c);
        }

        if (sel != null) {
            switch (comb) {
            case ' ':
                sel = this.getSelectorFactory().createDescendantSelector(sel, simpleSel);
                break;
            case '+':
                sel = this.getSelectorFactory().createDirectAdjacentSelector(sel.getSelectorType(), sel, simpleSel);
                break;
            case '>':
                sel = this.getSelectorFactory().createChildSelector(sel, simpleSel);
                break;
            }
        } else {
            sel = simpleSel;
        }

        return sel;
    }
}

//
// class
//   : '.' IDENT
//   ;
//
Condition _class(Condition pred) :
{
    Token t;
}
{
    <DOT> t = <IDENT>
    {
        Condition c = this.getConditionFactory().createClassCondition(null, t.image);
        return (pred == null) ? c : this.getConditionFactory().createAndCondition(pred, c);
    }
}

//
// element_name
//   : IDENT | '*'
//   ;
//
SimpleSelector elementName() :
{
    Token t;
}
{
  t=<IDENT>
  { return this.getSelectorFactory().createElementSelector(null, unescape(t.image)); }
  | <ASTERISK>
  { return this.getSelectorFactory().createElementSelector(null, null); }
}

//
// attrib
//   : '[' S* IDENT S* [ [ '=' | INCLUDES | DASHMATCH ] S*
//     [ IDENT | STRING ] S* ]? ']'
//   ;
//
Condition attrib(Condition pred) :
{
    Token t;
    String name = null;
    String value = null;
    int type = 0;
}
{
    <LSQUARE> ( <S> )*
    t = <IDENT> { name = unescape(t.image); } ( <S> )*
    (
        (
            <EQUALS> { type = 1; }
            |
            <INCLUDES> { type = 2; }
            |
            <DASHMATCH> { type = 3; }
        )
        ( <S> )*
        (
            t = <IDENT> { value = t.image; }
            |
            t = <STRING> { value = unescape(t.image); }
        )
        ( <S> )*
    )?
    <RSQUARE>

    {
        Condition c = null;
        switch (type) {
        case 0:
            c = this.getConditionFactory().createAttributeCondition(name, null, false, null);
            break;
        case 1:
            c = this.getConditionFactory().createAttributeCondition(name, null, false, value);
            break;
        case 2:
            c = this.getConditionFactory().createOneOfAttributeCondition(name, null, false, value);
            break;
        case 3:
            c = this.getConditionFactory().createBeginHyphenAttributeCondition(name, null, false, value);
            break;
        }
        return (pred == null) ? c : this.getConditionFactory().createAndCondition(pred, c);
    }
}

//
// pseudo
//   : ':' [ IDENT | FUNCTION S* IDENT S* ')' ]
//   ;
//
Condition pseudo(Condition pred) :
{
    Condition c;
    Token t;
    String function;
    String arg;
}
{
    <COLON>
    (
        t = <IDENT>
        {
            // There appears to be an issue here regarding "first-letter" & "first-line"
            String s = unescape(t.image);
		    c = this.getConditionFactory().createPseudoClassCondition(null, s);
            return (pred == null)
                ? c
                : this.getConditionFactory().createAndCondition(pred, c);
        }
        |
        (
            t = <FUNCTION> { function = unescape(t.image); } ( <S> )*
            t = <IDENT> { arg = unescape(t.image); } ( <S> )*
            <RROUND>
            {
                if (function.equalsIgnoreCase("lang(")) {
                    c = this.getConditionFactory().createLangCondition(unescape(arg));
                    return (pred == null)
                        ? c
                        : this.getConditionFactory().createAndCondition(pred, c);
                } else {
                    throw new CSSParseException(
                        "Invalid pseudo function name " + function,
                        getLocator());
                }
            }
        )
    )
}

Condition hash(Condition pred) :
{
    Token t;
}
{
    t = <HASH>
    {
        Condition c = this.getConditionFactory().createIdCondition(t.image.substring(1));
        return (pred == null) ? c : this.getConditionFactory().createAndCondition(pred, c);
    }
}

void styleDeclaration()  :
{
}
{
	<LBRACE> ( <S> )*
	( declaration() )?
	( <SEMICOLON> ( <S> )* ( declaration() )? )*
	<RBRACE>
}

//
// declaration
//   : property ':' S* expr prio?
//   |
//   ;
//
void declaration() throws ParseException :
{
  String p;
  LexicalUnit e;
  boolean priority = false;
}
{
    try
    {
        p = property()
        <COLON> ( <S> )*
        e = expr()
        ( priority = prio() )?
        {
            this.handleProperty(p, e, priority);
        }
    }
    catch (CSSParseException ex)
    {
        this.getErrorHandler().error(ex);
        error_skipdecl();
    }
    catch (ParseException ex)
    {
        this.getErrorHandler().error(this.toCSSParseException(ex));
        error_skipdecl();
    }
}

//
// prio
//   : IMPORTANT_SYM S*
//   ;
//
boolean prio() :
{
}
{
  <IMPORTANT_SYM> ( <S> )*
  { return true; }
}

//
// expr
//   : term [ operator term ]*
//   ;
//
// TODO: Deal with the operator
//
LexicalUnit expr() :
{
    LexicalUnit head;
    LexicalUnit body;
}
{
    head = term(null) { body = head; }
    ( ( body = operator(body) )? body = term(body) )*
    { return head; }
}

//
// term
//   : unary_operator?
//     [ NUMBER S* | PERCENTAGE S* | LENGTH S* | EMS S* | EXS S* | ANGLE S* |
//       TIME S* | FREQ S* | function ]
//   | STRING S* | IDENT S* | URI S* | RGB S* | UNICODERANGE S* | hexcolor
//   ;
//
LexicalUnit term(LexicalUnit prev) :
{
  Token t;
  char op = ' ';
  String s;
  LexicalUnit value = null;
//  RGBColor color;
//  HexColor h;
//  CSSValueImpl value = null;
}
{
/*
  ( ( op = unaryOperator() )?
  ( ( t = <NUMBER>    { value = new CSSValueImpl( CSSPrimitiveValue.CSS_NUMBER, new Float( op + t.image ) ); }
    | t = <PERCENTAGE>  { value = new CSSValueImpl( CSSPrimitiveValue.CSS_PERCENTAGE, new Float( op + t.image ) ); }
    | t = <LENGTH_PX>   { value = new CSSValueImpl( CSSPrimitiveValue.CSS_PX, new Float( op + t.image ) ); }
    | t = <LENGTH_CM>   { value = new CSSValueImpl( CSSPrimitiveValue.CSS_CM, new Float( op + t.image ) ); }
    | t = <LENGTH_MM>   { value = new CSSValueImpl( CSSPrimitiveValue.CSS_MM, new Float( op + t.image ) ); }
    | t = <LENGTH_IN>   { value = new CSSValueImpl( CSSPrimitiveValue.CSS_IN, new Float( op + t.image ) ); }
    | t = <LENGTH_PT>   { value = new CSSValueImpl( CSSPrimitiveValue.CSS_PT, new Float( op + t.image ) ); }
    | t = <LENGTH_PC>   { value = new CSSValueImpl( CSSPrimitiveValue.CSS_PC, new Float( op + t.image ) ); }
    | t = <EMS>     { value = new CSSValueImpl( CSSPrimitiveValue.CSS_EMS, new Float( op + t.image ) ); }
    | t = <EXS>     { value = new CSSValueImpl( CSSPrimitiveValue.CSS_EXS, new Float( op + t.image ) ); }
    | t = <ANGLE_DEG>   { value = new CSSValueImpl( CSSPrimitiveValue.CSS_DEG, new Float( op + t.image ) ); }
    | t = <ANGLE_RAD>   { value = new CSSValueImpl( CSSPrimitiveValue.CSS_RAD, new Float( op + t.image ) ); }
    | t = <ANGLE_GRAD>  { value = new CSSValueImpl( CSSPrimitiveValue.CSS_GRAD, new Float( op + t.image ) ); }
    | t = <TIME_MS>   { value = new CSSValueImpl( CSSPrimitiveValue.CSS_MS, new Float( op + t.image ) ); }
    | t = <TIME_S>    { value = new CSSValueImpl( CSSPrimitiveValue.CSS_S, new Float( op + t.image ) ); }
    | t = <FREQ_HZ>   { value = new CSSValueImpl( CSSPrimitiveValue.CSS_HZ, new Float( op + t.image ) ); }
    | t = <FREQ_KHZ>    { value = new CSSValueImpl( CSSPrimitiveValue.CSS_KHZ, new Float( op + t.image ) ); }
    | s = function()    { value = new CSSValueImpl( CSSPrimitiveValue.CSS_IDENT, op + s ); } )
  | t = <STRING>      { value = new CSSValueImpl( CSSPrimitiveValue.CSS_STRING, op + t.image ); }
  | t = <IDENT>     { value = new CSSValueImpl( CSSPrimitiveValue.CSS_IDENT, op + t.image ); }
  | t = <URI>       { value = new CSSValueImpl( CSSPrimitiveValue.CSS_URI, op + t.image ); }
  | t = <UNICODERANGE>  { value = new CSSValueImpl( CSSPrimitiveValue.CSS_IDENT, op + t.image ); }
  | color = rgb()     { value = new CSSValueImpl( CSSPrimitiveValue.CSS_RGBCOLOR, color ); }
  | color = hexcolor()  { value = new CSSValueImpl( CSSPrimitiveValue.CSS_RGBCOLOR, color ); }
  | t = <DIMEN>     { value = new CSSValueImpl( CSSPrimitiveValue.CSS_DIMENSION, new Float( op + t.image ) ); }
  | t = <INHERIT>     { value = new CSSValueImpl( CSSPrimitiveValue.CSS_INHERIT, op + t.image ); } )
  ( <S> )* )
  { return value; }
*/
    ( op = unaryOperator() )?
    (
        ( t = <NUMBER>
        {
            try
            {
                value = LexicalUnitImpl.createNumber(prev, intValue(op, t.image));
            }
            catch (NumberFormatException e)
            {
                value = LexicalUnitImpl.createNumber(prev, floatValue(op, t.image));
            }
        }
        | t = <PERCENTAGE>  { value = LexicalUnitImpl.createPercentage(prev, floatValue(op, t.image)); }
        | t = <LENGTH_PX>   { value = LexicalUnitImpl.createPixel(prev, floatValue(op, t.image)); }
        | t = <LENGTH_CM>   { value = LexicalUnitImpl.createCentimeter(prev, floatValue(op, t.image)); }
        | t = <LENGTH_MM>   { value = LexicalUnitImpl.createMillimeter(prev, floatValue(op, t.image)); }
        | t = <LENGTH_IN>   { value = LexicalUnitImpl.createInch(prev, floatValue(op, t.image)); }
        | t = <LENGTH_PT>   { value = LexicalUnitImpl.createPoint(prev, floatValue(op, t.image)); }
        | t = <LENGTH_PC>   { value = LexicalUnitImpl.createPica(prev, floatValue(op, t.image)); }
        | t = <EMS>         { value = LexicalUnitImpl.createEm(prev, floatValue(op, t.image)); }
        | t = <EXS>         { value = LexicalUnitImpl.createEx(prev, floatValue(op, t.image)); }
        | t = <ANGLE_DEG>   { value = LexicalUnitImpl.createDegree(prev, floatValue(op, t.image)); }
        | t = <ANGLE_RAD>   { value = LexicalUnitImpl.createRadian(prev, floatValue(op, t.image)); }
        | t = <ANGLE_GRAD>  { value = LexicalUnitImpl.createGradian(prev, floatValue(op, t.image)); }
        | t = <TIME_MS>     { value = LexicalUnitImpl.createMillisecond(prev, floatValue(op, t.image)); }
        | t = <TIME_S>      { value = LexicalUnitImpl.createSecond(prev, floatValue(op, t.image)); }
        | t = <FREQ_HZ>     { value = LexicalUnitImpl.createHertz(prev, floatValue(op, t.image)); }
        | t = <FREQ_KHZ>    { value = LexicalUnitImpl.createKiloHertz(prev, floatValue(op, t.image)); }
        | value = function(prev)
        )
    | t = <STRING>          { value = new LexicalUnitImpl(prev, LexicalUnit.SAC_STRING_VALUE, t.image); }
    | t = <IDENT>           { value = new LexicalUnitImpl(prev, LexicalUnit.SAC_IDENT, t.image); }
    | t = <URI>             { value = new LexicalUnitImpl(prev, LexicalUnit.SAC_URI, t.image); }
    | t = <UNICODERANGE>    { value = new LexicalUnitImpl(prev, LexicalUnit.SAC_UNICODERANGE, t.image); }
    | value = rgb(prev)
    | value = hexcolor(prev)
    | t = <DIMEN>
    {
        int n = getLastNumPos(t.image);
        value = LexicalUnitImpl.createDimension(
            prev,
            floatValue(op, t.image.substring(0, n+1)),
            t.image.substring(n+1));
    }
    | t = <INHERIT>         { value = new LexicalUnitImpl(prev, LexicalUnit.SAC_INHERIT, t.image); }
    )
    ( <S> )*
    { return value; }
}

//
// function
//   : FUNCTION S* expr ')' S*
//   ;
//
LexicalUnit function(LexicalUnit prev) :
{
    Token t;
    LexicalUnit params;
}
{
    t = <FUNCTION> ( <S> )*
    params = expr()
    <RROUND>
    {
        return this.functionInternal(prev, t, params);
    }
}

//
// rgb
//   : RGB S* expr ')' S*
//   ;
//
LexicalUnit rgb(LexicalUnit prev) :
{
    Token t;
    LexicalUnit params;
}
{
    t = <RGB> ( <S> )*
    params = expr()
    <RROUND>
    {
        return LexicalUnitImpl.createRgbColor(prev, params);
    }
}

//
// hexcolor
//   : HASH S*
//   ;
//
LexicalUnit hexcolor(LexicalUnit prev) :
{
    Token t;
}
{
    t = <HASH>
    {
        return this.hexcolorInternal(prev, t);
    }
}

JAVACODE
void skipSelector() {
    Token t = getToken(1);
    while (t.kind != COMMA && t.kind != SEMICOLON && t.kind != LBRACE && t.kind != EOF ) {
        getNextToken();
        t = getToken(1);
    }
}

JAVACODE
String skip() {
  StringBuffer sb = new StringBuffer();
  int nesting = 0;
  Token t = getToken(0);
  if (t.image != null) {
    sb.append(t.image);    
  }
  do {
    t = getNextToken();
    if (t.kind == EOF)
      break;
    sb.append(t.image);
    if (t.kind == LBRACE)
      nesting++;
    else if (t.kind == RBRACE)
      nesting--;
    else if (t.kind == SEMICOLON && nesting <= 0)
      break;
  }
  while ((t.kind != RBRACE) || (nesting > 0));

  return sb.toString();
}

JAVACODE
void error_skipblock()
{
    Token t;
    int nesting = 0;
    do
    {
        t = getNextToken();
        if (t.kind == LBRACE)
        {
            nesting++;
        }
        else if (t.kind == RBRACE)
        {
            nesting--;
        }
        else if (t.kind == EOF)
        {
            break;
        }
    }
    while ((t.kind != RBRACE) || (nesting > 0));
}

JAVACODE
void error_skipdecl()
{
    int nesting = 0;
    Token t = getToken(1);
    if (t.kind == LBRACE)
    {
        error_skipblock();
    }
    else
    {
        while (t.kind != SEMICOLON && t.kind != RBRACE && t.kind != EOF )
        {
            getNextToken();
            t = getToken(1);
        }
    }
}

JAVACODE
void error_skipAtRule()
{
    Token t = null;
    do
    {
        t = getNextToken();
    }
    while (t.kind != SEMICOLON);
}